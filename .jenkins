#!/usr/bin/env groovy

pipeline {

  agent any

  environment {
    IMAGE_NAME = 'vaporio/snmp-plugin'
    GOVERSION = '1.12'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    // Run linting on project source code.
    stage('Lint') {
      agent {
        docker {
          image 'vaporio/golang:1.13'
          reuseNode true
        }
      }
      steps {
        sh 'make lint'
      }
    }

    stage('Snapshot Build') {
      steps {
        script {
          /* This replicates some of what the docker agent would do if this were
             running natively in kube. We would version these same params in
             the agent config. This is a bit of a phaux pre-dep test to getting
             agents running in kube. the containers are acting just like the
             host agent would, but in spurts.

             Note: the importance of the --group-add docker in the parameters.
             Without it, docker in agent is mysteriously permission
             locked despite having a GID present in the container.
          */
          docker.image('vaporio/jenkins-agent-golang:latest').inside('-v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker --group-add docker') {
            sh 'goreleaser release --snapshot --skip-publish --rm-dist'
          }
        }
      }
    }

    // Run tests on project source code.
    // These tests run very differently when run from the Makefile and in CI.
    // From the Makefile we start up the emulator in a container and expose port 1024
    // on the host. The tests run on the host and connect through port 1024.
    // Here we start up the emulator in a container and expose port 1024 on the host.
    // The tests run in a golang container and connect to the exposed port 1024 on the host.
    // This could cause problems with parallel builds, but it is a place to start.
    stage('Test') {
      steps {
        // Critial section to avoid container name collisions.
        lock('Test') {
          script {
            // Build the SNMP emulator image.
            sh 'docker build -t emulator_snmp-emulator-ups emulator'

            // Start the SNMP emulator.
            docker.image('emulator_snmp-emulator-ups:latest').withRun(
              "-m 1024MB -p 1024:1024/udp --name snmp-emulator-ups", // args
              "./start_snmp_emulator.sh ./data 1024 snmp-emulator-ups.log" // command
              ) { se ->

              // Stand up a container to run the tests. Put it on the host network.
              docker.image('vaporio/golang:1.13').inside("--network=host") { testContainer ->
                sh 'go test -cover -v ./...'
              } // end testContainer
            } // end emulator container
          } // end script
        } // end lock
      } // end steps
    } // end stage

    // Build the image with the 'edge' tag and publish it to DockerHub. This
    // should only be run on the master branch (e.g. PR merge)
    stage('Publish Latest') {
      when {
        branch 'master'
      }
      steps {
        withDockerRegistry(registry: [credentialsId: 'vio-docker-hub']) {
          sh 'docker push ${IMAGE_NAME}:latest'
        }
      }
    }

    stage('Tagged Release') {
      when {
        // example matches: 1.2.3, 1.2.3-dev
        tag pattern: '(0|[1-9]*)\\.(0|[1-9]*)\\.(0|[1-9]*)(-(\\S*))?$', comparator: "REGEXP"
      }
      environment {
        GITHUB_TOKEN = credentials('vio-bot-gh-token')
      }
      steps {
        script {
          docker.image('vaporio/jenkins-agent-golang:latest').inside('-v /var/run/docker.sock:/var/run/docker.sock -v /usr/bin/docker:/usr/bin/docker -e GITHUB_TOKEN=$GITHUB_TOKEN --group-add docker') {
            withDockerRegistry(registry: [credentialsId: 'vio-docker-hub']) {
              sh 'goreleaser release --rm-dist'
            }
          }
        }
      }
    }

  }
}
